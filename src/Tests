using FastGaussQuadrature
using Roots
using Sobol
using Plots
using Distributions
using NullableArrays
using DataStructures

a = 4
b = 1
coef1 = (a-b)/2
coef2 = (a+b)/2

n = 10,15,20

q(x)=2/sqrt(x)
q(4)

q_trans(x) = coef1 * 2/sqrt(coef1*x+coef2)

rule = gausslegendre(10)

nodes = values(rule)[1,]
weights = values(rule)[2,]
weighted_q = weights .* map(q_trans, nodes)

plot(nodes, weighted_q)
plot!(q_trans)

approx = sum(weights .* weighted_q)
error = 4 - approx



n = [10, 15, 20]
z =

function plot1(n)
    q_trans(x) = coef1 * 2/sqrt(coef1*x+coef2)
    GL= []
    println("Results using Gauss Legendre rule : ")
        for i in n
            rule = gausslegendre(i)
            nodes = values(rule)[1,]
            weights = values(rule)[2,]
            weighted_q = weights .* map(q_trans, nodes)
            approx = sum(weighted_q)

            println("The approximated change in consumer surplus when n=$i is $approx.")
            println("The distance between the true result and the approximation when n=$i is ", 4 - approx)
            push!(GL, ["x$i" => nodes, "y$i" => weighted_q])
    end
    gl10 = plot(GL[1][1][2], GL[1][2][2])
    plot!(q_trans)
    gl15 = plot(GL[2][1][2], GL[2][2][2])
    plot!(q_trans)
    gl20 = plot(GL[3][1][2], GL[3][2][2])
    plot!(q_trans)
    GLplot = plot(gl10, gl15, gl20, layout=(3,1))
end

plot1(n)


function rand_uniform(a, b, n)
    a + rand(n)*(b - a)
end

function plot2(n)
    println("Results using Monte Carlo integration : ")
    q_trans(x) = coef1 * 2/sqrt(coef1*x+coef2)
    MC = []
        for i in n
            random = rand_uniform(-1, 1, i)
            x = sort(random)
            y = map(q_trans, x)
            push!(MC, ["x$i" => x, "y$i" => y])
            approx = sum(y)/i
            println("The approximated change in consumer surplus when n=$i is $approx.")
            println("The distance between the true result and the approximation when n=$i is ", 4 - approx)
        end
    mc10 = scatter(MC[1][1][2], MC[1][2][2])
    plot!(q_trans)
    mc15 = scatter(MC[2][1][2], MC[2][2][2])
    plot!(q_trans)
    mc20 = scatter(MC[3][1][2], MC[3][2][2])
    plot!(q_trans)
    MCplot = plot(mc10, mc15, mc20, layout=(3,1))
end
plot2(n)



function plot3(n)

    function sobol(j)
       s = ScaledSobolSeq(1, [-1.0], [1.0])
       seq = hcat([next(s) for i in 1:j]...)
       a = []
        for i in 1:j
            push!(a, seq[1, i])
        end
    return a
    end

    q_trans(x) = coef1 * 2/sqrt(coef1*x+coef2)
    QMC = []
    println("Results using Quasi Monte Carlo integration : ")
        for j in n
            rand = sobol(j)
            x = sort(rand)
            y = map(q_trans, x)
            push!(QMC, ["x$j" => x, "y$j" => y])
            approx = sum(y)/j
            println("The approximated change in consumer surplus when n=$j is $approx.")
            println("The distance between the true result and the approximation when n=$j is ", 4 - approx)
        end
    qmc10 = scatter(QMC[1][1][2], QMC[1][2][2])
    plot!(q_trans)
    qmc15 = scatter(QMC[2][1][2], QMC[2][2][2])
    plot!(q_trans)
    qmc20 = scatter(QMC[3][1][2], QMC[3][2][2])
    plot!(q_trans)
    QMCplot = plot(qmc10, qmc15, qmc20, layout=(3,1))
end

plot3(n)



function question_1b(n)
    q_trans(x) = coef1 * 2/sqrt(coef1*x+coef2)
    rule = gausslegendre(n)
    nodes = values(rule)[1,]
    weights = values(rule)[2,]
    weighted_q = weights .* map(q_trans, nodes)
    approx = sum(weighted_q)
    println("The approximated change in consumer surplus when n=$n is $approx.")
    println("The distance between the true result and the approximation when n=$n is ", 4 - approx)
    scatter(nodes, map(q_trans, nodes), label = "Gauss-Legendre", xlab ="Integration nodes", ylab="Function Value" )
    plot!(q_trans, label = "Scaled Demand Function")
end


function question_1c(n)

    function rand_uniform(a, b, n)
        a + rand(n)*(b - a)
    end

    q_trans(x) = coef1 * 2/sqrt(coef1*x+coef2)
    random = rand_uniform(-1, 1, n)
    x = sort(random)
    y = map(q_trans, x)
    approx = sum(y)/n
    println("Results using Monte Carlo integration : ")
    println("The approximated change in consumer surplus when n=$n is $approx.")
    println("The distance between the true result and the approximation when n=$n is ", 4 - approx)
    scatter!(x, y, label = "Monte Carlo", xlab ="Integration nodes", ylab="Function Value" )

end


function question_1d(n)

    #= We define a function Sobol that generates the sobol
    sequence in a usable way =#

    function sobol(j)
       s = ScaledSobolSeq(1, [-1.0], [1.0])
       seq = hcat([next(s) for i in 1:j]...)
       a = []
        for i in 1:j
            push!(a, seq[1, i])
        end
    return a
    end
    q_trans(x) = coef1 * 2/sqrt(coef1*x+coef2)
    rand = sobol(n)
    x = sort(rand)
    y = map(q_trans, x)
    approx = sum(y)/n
    println("Results using Quasi Monte Carlo integration : ")
    println("The approximated change in consumer surplus when n=$n is $approx.")
    println("The distance between the true result and the approximation when n=$n is ", 4 - approx)
    scatter!(x, y, label = "Q. Monte Carlo", xlab ="Integration nodes", ylab="Function Value" )
end


plotlyjs()
plots = []
for n in (10,15,20)
    info("============================")
    info("now showing results for n=$n")
    info("question 1b:")
    question_1b(n)
    info("question 1c:")
    question_1c(n)
    info("question 1d:")
    push!(plots, question_1d(n))
end

plot(plots[1], plots[2], plots[3])


question_1b(10)
question_1c(10)
question_1d(10)
